# Security Architecture

This document details the security mechanisms for the autonomous AI agent, focusing on credential management and the principle of least privilege.

## 1. Secure Credential Management with HashiCorp Vault

A dedicated, highly secure service is required to manage all secrets. We recommend **HashiCorp Vault** for this purpose.

### 1.1. Vault's Role
Vault will serve as the single, centralized source of truth for all credentials required by the agent. Storing secrets in configuration files, environment variables, or code is strictly prohibited. The agent's Central Orchestrator will be the only component that communicates directly with Vault.

### 1.2. Agent Authentication
The Central Orchestrator must securely authenticate with Vault to retrieve secrets. We recommend using Vault's **AppRole** authentication method:
- An **AppRole** will be created specifically for the agent.
- The `RoleID` will be configured in the agent's startup configuration.
- The `SecretID` will be injected into the agent's environment at runtime through a secure mechanism (e.g., a Kubernetes secret, an encrypted file).
- The agent will use the `RoleID` and `SecretID` to log in to Vault and obtain a time-to-live (TTL) limited Vault token. It will be responsible for renewing this token as needed.

### 1.3. Dynamic Secrets
For services that support it, Vault will generate **dynamic, on-demand credentials**. This means the credentials are created for a specific task and automatically expire after use.
- **Neon (Postgres):** Vault's Database Secrets Engine will be configured to connect to Neon. When the agent needs to access the database, it will request credentials from Vault, which will create a new Postgres user with a short TTL.
- **Redis:** While Redis itself doesn't have a dedicated secrets engine, we can use a combination of the KV engine and custom rotation scripts to manage Redis passwords.
- **Lambda Labs:** API keys for Lambda Labs will be stored in Vault's KV secrets engine. We will implement a rotation policy for these keys.

### 1.4. Secrets Engines by Service
- **GitHub:** A dedicated **GitHub App** will be created. The App's private key will be stored securely in Vault. The agent will use this key to generate short-lived installation access tokens for specific repositories. This is more secure and provides more granular permissions than a Personal Access Token (PAT).
- **Pulumi:** The `PULUMI_ACCESS_TOKEN` will be stored in Vault's KV secrets engine.
- **Qdrant:** The `QDRANT_URL` and any API keys will be stored in Vault's KV secrets engine.
- **Estuary:** API keys for Estuary will be stored in Vault's KV secrets engine.

## 2. IAM Roles and Policies (Principle of Least Privilege)

This section outlines the specific permissions the agent will be granted for each service, following the principle of least privilege.

### 2.1. GitHub
A **GitHub App** will be used instead of a Personal Access Token (PAT). The App will be installed only on the target repository.
- **Repository Permissions:**
  - `Contents`: Read & write (for checking out code, committing changes)
  - `Pull requests`: Read & write (for creating and managing PRs)
  - `Issues`: Read & write (for creating and updating issues)
- **Organization Permissions:** None.

### 2.2. Pulumi
The agent's `PULUMI_ACCESS_TOKEN` will grant it permissions to manage stacks within a dedicated Pulumi project.
- **Stack Permissions:** `create`, `read`, `update`, `delete`.

### 2.3. Lambda Labs
The agent's API key will have the following permissions:
- `instance_launch`: To provision new instances.
- `instance_terminate`: To destroy instances.
- `instance_list`: To view existing instances.
- `ssh_key_manage`: To add and remove SSH keys for instance access.

### 2.4. Managed Services (Qdrant, Redis, Neon, Estuary)
For these services, the agent will be granted administrative privileges on the service instance itself. Access will be controlled through network policies and dynamic, short-lived credentials from Vault.
- **Qdrant:** Full access to create/delete collections and manage points.
- **Redis:** Full access to read/write keys.
- **Neon:** The dynamic credentials will grant `CREATE`, `READ`, `WRITE`, `DELETE` on the target database.
- **Estuary:** Full access to manage data and collections.

## 3. Credential Rotation

A strict credential rotation policy is essential to limit the impact of a potential compromise.

### 3.1. Automated Rotation
All static secrets (those not dynamically generated by Vault) must be automatically rotated. This includes:
- The GitHub App's private key.
- The `PULUMI_ACCESS_TOKEN`.
- API keys for Lambda Labs and Estuary.

### 3.2. Rotation Schedule
- **Static Secrets:** All static secrets will be rotated every **90 days**.
- **Dynamic Secrets:** Credentials for Neon and Redis will be generated with a short TTL (e.g., 5-30 minutes), effectively rotating them on every use.
- **Vault Token:** The agent's own Vault token will have a TTL of 1 hour and will be renewed by the agent as needed.

### 3.3. Emergency Rotation
A documented, automated procedure will be created to immediately revoke and rotate any secret in the event of a suspected compromise. This procedure will be triggered through a "break-glass" API call to the orchestration engine.

### 3.4. Implementation
- **Vault:** Vault's built-in rotation capabilities will be used where possible.
- **Scheduled Jobs:** For services without native Vault integration, a scheduled job (e.g., a Kubernetes CronJob, a GitHub Action) will be created to call the service's API to revoke the old credential and then update the value in Vault.